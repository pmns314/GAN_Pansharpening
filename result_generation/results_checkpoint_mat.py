""" Generate all the images generated by all the checkpoints and saves them in .mat files"""

import argparse
import os
import pandas as pd
import torch
from scipy import io as scio
from torch.utils.data import DataLoader
import constants
from dataset.DatasetPytorch import DatasetPytorch
from pytorch_models.CNNs.APNN import APNN

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('-n', '--name_model',
                        default='test',
                        help='Provide name of the model. Defaults to test',
                        type=str
                        )
    parser.add_argument('-d', '--dataset_path',
                        default=f'{constants.DATASET_DIR}',
                        help='Provide path to the dataset. Defaults to ROOT/datasets',
                        type=str
                        )
    args = parser.parse_args()

    satellite = "W3"
    dataset_path = args.dataset_path
    model_name = args.name_model

    model_name = "W3_1_32_0001_mse"

    result_folder = f"./results/{satellite}_full3"
    if not os.path.exists(result_folder):
        os.makedirs(result_folder)

    result_model_folder = f"{result_folder}/{model_name}"
    if not os.path.exists(result_folder):
        os.makedirs(result_folder)

    model_folder = f"./pytorch_models/trained_models/{satellite}_all/{model_name}"
    model_path = f"{model_folder}/model.pth"
    tests = ["test_1_256", "test_3_512"]
    for test_index in [0, 1]:
        test_folder = f"{result_model_folder}/test_{test_index}"
        if not os.path.exists(test_folder):
            os.makedirs(test_folder)

        test_set_path = dataset_path + satellite + f"/{tests[test_index]}.h5"
        if os.path.exists(test_set_path):
            test_dataloader = DataLoader(DatasetPytorch(test_set_path),
                                         batch_size=64,
                                         shuffle=False)

            model = APNN(test_dataloader.dataset.channels)

            # Read Excel
            filename = f"{result_model_folder}/test_{test_index}.xlsx"
            if os.path.exists(filename):
                data = pd.read_excel(filename)
                start = data['Epoch'].loc[data.index[-1]]
            else:
                start = 1
            stop = len(os.listdir(f"{model_folder}/checkpoints"))

            # Generation Images
            pan, ms, _, gt = next(enumerate(test_dataloader))[1]
            if len(pan.shape) == 3:
                pan = torch.unsqueeze(pan, 0)
            gt = torch.permute(gt, (0, 2, 3, 1))
            gt = gt.detach().numpy()
            for i in range(start, stop):
                # Load Pre trained Model
                trained_model = torch.load(f"{model_folder}/checkpoints/checkpoint_{i}.pth", map_location=torch.device('cpu'))
                model.load_state_dict(trained_model['model_state_dict'])

                gen = model(ms, pan)
                # From NxCxHxW to NxHxWxC
                gen = torch.permute(gen, (0, 2, 3, 1))
                gen = gen.detach().numpy()

                print(f"Saving checkpoint_{i}.mat")
                scio.savemat(f"{test_folder}/checkpoint_{i}.mat",
                             dict(gen_decomposed=gen, gt_decomposed=gt))

    # out_gt = np.zeros((256, 256, 8))
    # out_gen = np.zeros((256, 256, 8))
    # n_patch = gen.shape[0]
    # dim_patch = gen.shape[1]
    # num_patch_per_row = 256 // dim_patch
    # row = -1
    # col = 0
    #
    # start_row = stop_row = 0
    # start_col = stop_col = 0
    # for i in range(n_patch):
    #     if i % num_patch_per_row == 0:
    #         start_col = 0
    #         start_row = stop_row
    #         stop_row = stop_row + dim_patch
    #     else:
    #         start_col = stop_col
    #     stop_col = start_col + dim_patch
    #     out_gt[start_row:stop_row, start_col:stop_col, :] = gt[i, :, :, :]
    #     out_gen[start_row:stop_row, start_col:stop_col, :] = gen[i, :, :, :]
    #
    #
    # plt.imshow(out_gt[:, :, :3])
    # plt.figure()
    # plt.imshow(out_gen[:, :, :3])
    # plt.show()

    #
